## 问题诊断
- 现象：解析文件成功，但导入失败；错误为“table trades has no column named order_status”。
- 根因：当前运行环境已存在的 SQLite 库 `data/trading.db` 的 `trades` 表是旧版本模式，缺少新字段；`init_database()` 仅在“表不存在”时创建，不会增量升级已有表。
- 代码参考：
  - 数据库初始化 `src/utils/database.py:41-70`
  - 交易插入 `src/utils/database.py:132-147`
  - 导入入口 `src/data_ingestion/data_importer.py:433-462`
  - 应用启动处调用初始化 `app.py:22-31`

## 修复方案
- 增加“自愈式”数据库模式迁移：在初始化之后检测已有列，自动补齐缺失列。
- 补充健壮插入逻辑：按数据库实际列动态构建 INSERT，避免旧库插入失败，作为迁移的保险措施。
- 提供安全备份与日志：迁移前备份数据库文件；迁移过程写入 `logs` 表。

## 技术实现
- 在 `DatabaseManager` 中新增：
  1. `expected_trades_schema` 字典：列名→类型/默认值/是否 NOT NULL/索引。
  2. `migrate_tables()`：
     - 使用 `PRAGMA table_info(trades)` 获取现有列。
     - 逐列检查缺失项，执行 `ALTER TABLE trades ADD COLUMN ...`：
       - `order_status TEXT`（可空）
       - `filled_quantity INTEGER`（可空）
       - `order_type TEXT`（可空）
       - `duration TEXT`（可空）
       - `time_slot TEXT`（可空）
       - `currency TEXT`（可空）
       - `market TEXT`（可空）
       - `brokerage REAL DEFAULT 0`（可空）
       - `tax REAL DEFAULT 0`（可空）
       - `net_amount REAL NOT NULL DEFAULT 0`
       - `trade_id TEXT`（可空），并创建唯一索引：`CREATE UNIQUE INDEX IF NOT EXISTS idx_trades_trade_id ON trades(trade_id)`。
     - 迁移前复制备份文件 `trading.db.bak`。
  3. 在 `init_database()` 末尾调用 `migrate_tables()`。
- 在 `insert_trade()`：
  - 运行时通过 `PRAGMA table_info(trades)` 取实际列集合；用“键交集”动态拼接 `INSERT INTO trades(<cols...>) VALUES(<placeholders...>)`，避免无该列时报错。
  - 对缺失但需要的业务字段（如 `net_amount`）在插入参数中兜底填充。

## 验证步骤
- 单元测试：
  - 构造一个缺列的临时库（不含 `order_status`），调用 `init_database()` 后应自动补列。
  - 运行现有测试 `tests/data_ingestion/test_data_importer.py` 确认不回归。
- 手动验证：
  - 启动应用，导入与截图一致的文件；应成功写入并在“当前数据库状态”显示新增记录。

## 风险与回滚
- 风险：对已有库的模式变更可能影响旧数据读取。
- 控制：
  - 迁移前自动备份；失败时恢复备份。
  - 所有新增列均为可空或有默认值，避免破坏既有行。

## 兼容性与后续
- 增加一次性“修复数据库结构”按钮（数据导入页），便于用户在 UI 中触发迁移与查看结果。
- 在 `logs` 表记录迁移动作与结果，用于审计与问题追踪。

以上方案将使旧库平滑升级到当前代码期望的模式，使导入数据稳定成功，并对未来模式演进具备可维护性。请确认是否按此方案实施。